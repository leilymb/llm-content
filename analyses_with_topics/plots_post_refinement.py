# -*- coding: utf-8 -*-
"""Copy of Recat_plots.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12d3B_MK2Oi1Kz017B8er-pRw4E1kXRrW

note: change runtime type to T4 gpu (should be free, and significantly speeds up

**Creating bertopic-like bar chart and frequency using the recategorized responses**
This notebook loads LLM recategorized topics (new_theme) from recategorized_13_full.csv, attaches rating from all_responses_current.csv (via the urge subset), and produces a BERTopic-style bar chart by computing class-based TF-IDF on bigrams to surface the top terms per LLM theme.
"""

!pip install -U kaleido

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install bertopic

from google.colab import drive
from bertopic import BERTopic
from sklearn.feature_extraction.text import CountVectorizer
import matplotlib.pyplot as plt
import pandas as pd
import re
import textwrap
from datetime import datetime
import plotly.io as pio
import numpy as np
from bertopic.vectorizers import ClassTfidfTransformer
from scipy.sparse import vstack
import seaborn as sns
from sklearn.feature_extraction.text import ENGLISH_STOP_WORDS
import plotly.express as px

drive.mount('/content/drive')

"""**Data Loading and Cleaning**:

Data Path: Defines the path to the CSV file containing responses.

Reading Data: Loads the data into a pandas DataFrame.

Cleaning Responses: Standardizes various representations of 'NA' and removes irrelevant or missing responses.
"""

# read in data
project_folder = '/content/drive/MyDrive/ProjectSafe_CleanCode/'
data_folder = '/content/drive/MyDrive/ProjectSafe_CleanCode/data/'
data_path = data_folder + 'all_responses_current.csv'
dat = pd.read_csv(data_path)
df_path = data_folder + '/Recategorization/recategorized_13_full.csv'
df = pd.read_csv(df_path)

df

replacement_dict = {
    'na':'NA',
    'na ':'NA',
    'Na':'NA',
    'n/a':'NA',
    'N/a':'NA',
    'N/A':'NA',
    'n\\a':'NA',
    'N\\A':'NA',
    'N\\A':'NA',
    'N/a.':'NA',
    'n/a':'NA',
    'n/A':'NA',
    '/a':'NA',
}
dat['response'] = dat['response'].replace(replacement_dict)
dat = dat[dat['response'].notna()]
dat = dat[dat['response'] != 'NA']
dat = dat[dat['response'] != '10']

dat

urge_df = dat[dat['type'] == 'urge']
intent_df = dat[dat['type'] == 'intent']
desire_df = dat[dat['type'] == 'desire']

# --- BARCHART USING CLASS-BASED TF-IDF FOR LLM THEMES ---

#Convert ENGLISH_STOP_WORDS to a list before modification
custom_stopwords = list(ENGLISH_STOP_WORDS)
#Remove unwanted stop words from the list
custom_stopwords = [word for word in custom_stopwords if word not in {'none', 'no', 'not'}]

vectorizer = CountVectorizer(ngram_range=(2, 2), stop_words=custom_stopwords)
df['response'] = df['Document'].astype(str)

#Assign sequential theme IDs
theme_mapping = {theme: idx for idx, theme in enumerate(sorted(df['new_theme'].unique()))}
df['theme_id'] = df['new_theme'].map(theme_mapping)

#Group all responses by theme_id and join them
grouped_docs = df.groupby('theme_id')['response'].apply(lambda x: ' '.join(x)).reset_index()
X_grouped = vectorizer.fit_transform(grouped_docs['response'])
feature_names = np.array(vectorizer.get_feature_names_out())

#Apply class-based TF-IDF correctly to grouped docs
ctfidf = ClassTfidfTransformer()
X_ctfidf = ctfidf.fit_transform(X_grouped)

#Extract top words per class
theme_words = {}
for idx, theme_id in enumerate(grouped_docs['theme_id']):
    row = X_ctfidf[idx].toarray().flatten()
    top_n = row.argsort()[::-1][:3]
    top_words = feature_names[top_n]
    top_scores = row[top_n]
    theme_words[theme_id] = list(zip(top_words, top_scores))

colors = sns.color_palette("tab20", len(theme_words))

#Plot like BERTopic's visualizer
label_map = {
    0: "Normal life thoughts",
    1: "Existential reflections",
    2: "Family & friends reactions",
    3: "Thinking of a plan",
    4: "Ruminating about death",
    5: "Passive suicidal ideation",
    6: "Depressed, exhausted",
    7: "Images of self-harm and suicide methods",
    8: "Happy life thoughts",
    9: "Low self-esteem and self-hatred",
    10: "Active suicidal ideation",
    11: "Not sure / I don't know",
    12: "None / No thoughts"
}

fig, axes = plt.subplots(3, 5, figsize=(39, 22))
axes = axes.flatten()

for i, (theme_id, words_scores) in enumerate(theme_words.items()):
    words, scores = zip(*words_scores)
    ax = axes[i]
    color = [colors[i]] * len(words)
    sns.barplot(x=scores, y=words, ax=ax, palette=color, width=0.5)
#Wrap long titles (â‰¥ 2 words) by inserting a line break after the 2nd word
    raw_title = label_map.get(theme_id, f"Theme {theme_id}")
    title_words = raw_title.split()
    if len(title_words) > 2:
      title = f"{title_words[0]} {title_words[1]}\n{' '.join(title_words[2:])}"
    elif len(title_words) == 2:
      title = f"{title_words[0]}\n{title_words[1]}"
    else:
      title = raw_title

    ax.set_title(title, fontsize=34, pad=30,y=1)
    ax.set_xlabel("")
    ax.set_ylabel("")
    ax.tick_params(axis='y', labelsize=29)  # y-tick (bigrams) font size
    ax.tick_params(axis='x', labelsize=25)  # x-tick font size

#Hide unused axes
for j in range(i+1, len(axes)):
    axes[j].axis('off')

plt.tight_layout(pad=3.0, rect=[0, 0.03, 1, 1])
#fig.savefig(data_folder + "llm_theme_barchart_opaque.png", dpi=300, bbox_inches='tight') #can add transparent=TRUE for transparent background
plt.show()

manual_labels = [
    "Normal life thoughts",
    "Existential reflections",
    "Family & friends reactions",
    "Thinking of plans",
    "Ruminative ideation",
    "Passive suicidal ideation",
    "Depressed, exhausted",
    "Self harm & suicide methods",
    "Happy life thoughts",
    "Low self-esteem",
    "Active suicidal ideation",
    "Not sure/I don't know",
    "None/No thoughts"
]

"""Themes/Topics as a function of ratings"""

# Use df and urge_df (must be same length and aligned)
df['rating'] = urge_df['rating'].values

# Count frequencies of each theme across ratings
theme_rating_counts = df.groupby(['rating', 'new_theme']).size().reset_index(name='count')

# Map integer theme IDs to descriptive labels
label_map = dict(enumerate(manual_labels))
theme_rating_counts['Theme'] = theme_rating_counts['new_theme'].map(label_map)


# Make sure 'rating' is treated as a categorical variable with all desired levels
theme_rating_counts['rating'] = theme_rating_counts['rating'].astype(int)

# Set explicit order for x-axis
category_order = list(range(11))  # 0 through 10

# Plot using plotly.express for interactivity
fig = px.line(
    theme_rating_counts,
    x = "rating",
    y="count",
    color="Theme",
    markers=True,
    #title="Frequency of Themes over Ratings",
    labels={"rating": "", "count": "Frequency"},
    template="plotly_white"
)

fig.update_layout(
    xaxis=dict(
        tickmode='array',
        tickvals=category_order,
        tickfont=dict(size=19)
    ),
    yaxis=dict(
        tickfont=dict(size=19)
    ),
    legend=dict(
        title_font=dict(size=28),
        font=dict(size=23)
    ),
    font=dict(size=19),
    legend_title_text="Theme",
    width=1300,
    height=600,
    margin=dict(l=40, r=40, t=60, b=40)
)


fig.show()

#####SAME PLOT AS ABOVE WITH THICKER LINES AND DIFFERENT COLOURS####
# Use df and urge_df (must be same length and aligned)
df['rating'] = urge_df['rating'].values

# Count frequencies of each theme across ratings
theme_rating_counts = df.groupby(['rating', 'new_theme']).size().reset_index(name='count')

# Map integer theme IDs to descriptive labels
label_map = dict(enumerate(manual_labels))
theme_rating_counts['Theme'] = theme_rating_counts['new_theme'].map(label_map)


# Make sure 'rating' is treated as a categorical variable with all desired levels
theme_rating_counts['rating'] = theme_rating_counts['rating'].astype(int)

# Set explicit order for x-axis
category_order = list(range(11))  # 0 through 10

palette = px.colors.qualitative.Dark24


# Plot using plotly.express for interactivity
fig = px.line(
    theme_rating_counts,
    x = "rating",
    y="count",
    color="Theme",
    markers=True,
    color_discrete_sequence=palette,
    color_discrete_map={
        "Happy life thoughts": "#1f77b4",
        "Family & friends reactions": "#ff7f0e",
        "Passive suicidal ideation": "#2ca02c",
        "Active suicidal ideation": "#d62728"
    },
    #title="Frequency of Themes over Ratings",
    labels={"rating": "", "count": "Frequency"},
    template="plotly_white"
)
# make all lines thicker and markers a bit bigger
fig.update_traces(
    line=dict(width=4),
    marker=dict(size=8)
)

fig.update_layout(
    xaxis=dict(
        tickmode='array',
        tickvals=category_order,
        tickfont=dict(size=19)
    ),
    yaxis=dict(
        tickfont=dict(size=19)
    ),
    legend=dict(
        title_font=dict(size=28),
        font=dict(size=23)
    ),
    font=dict(size=19),
    legend_title_text="Theme",
    width=1300,
    height=600,
    margin=dict(l=40, r=40, t=60, b=40)
)


fig.show()

#fig.write_html(project_folder + "figures/theme_rating_plot_thick.html")

#Count number of responses per LLM theme per rating
topics_ratings_frequency = df.groupby(['rating', 'new_theme']).size().reset_index(name='Frequency')
topics_ratings_frequency

# Pivot to wide format
frequencies_wide = topics_ratings_frequency.pivot(index='rating', columns='new_theme', values='Frequency')
frequencies_wide.reset_index(inplace=True)
frequencies_wide.columns.name = None
frequencies_wide.columns = ['Rating'] + [f'Topic_{col}' for col in frequencies_wide.columns if col != 'rating']
frequencies_wide.fillna(0, inplace=True)
frequencies_wide

#Export
frequencies_wide.to_csv(data_folder + 'URGE_llm_topic_frequencies_wide_forSDI.csv', index=False)